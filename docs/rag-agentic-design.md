# RAG Agentic Design

## Overview

RAG is now **fully agentic** - it's exposed as MCP tools that agents can call when they need it, rather than being automatically injected. This means:

✅ **System works completely without RAG** - no dependencies, no automatic calls
✅ **RAG is optional** - appears as tools only if index exists
✅ **Agents decide** - they call RAG tools when they need semantic search
✅ **Graceful degradation** - if RAG unavailable, agents use MCP tools only

## How It Works

### Without RAG Index

```
User Query
    │
    ▼
[PREPROCESSOR] → Clean text
    │
    ▼
[PLANNER] → Has access to MCP tools:
    ├─ read_file
    ├─ analyze_codebase
    ├─ search_docs
    ├─ find_references
    └─ git_diff
    │
    ▼
[CODER/REVIEWER/etc.] → Work normally
```

**MCP tools list:** 6 tools (no RAG tools)

### With RAG Index

```
User Query
    │
    ▼
[PREPROCESSOR] → Clean text
    │
    ▼
[PLANNER] → Has access to MCP tools:
    ├─ read_file
    ├─ analyze_codebase
    ├─ search_docs
    ├─ find_references
    ├─ git_diff
    ├─ rag_search      ← NEW (if index exists)
    └─ rag_query       ← NEW (if index exists)
    │
    ▼
[CODER/REVIEWER/etc.] → Can also use RAG tools if needed
```

**MCP tools list:** 8 tools (RAG tools appear automatically)

## RAG Tools

### 1. `rag_search(query, top_k=5)`

**Purpose:** Semantic search in codebase using embeddings

**When agents use it:**
- Need to find relevant code snippets semantically
- Looking for similar patterns or implementations
- Searching for concepts rather than exact text

**Example:**
```python
# Agent calls:
rag_search("How does error handling work?", top_k=5)

# Returns:
"""
Found 5 relevant documents:

[1] orchestrator/orchestrator.py (relevance: 0.892)
try:
    result = await self._query_mcp(...)
except Exception as e:
    return f"Error: {str(e)}"
...

[2] api_server.py (relevance: 0.856)
...
"""
```

### 2. `rag_query(question, top_k=5)`

**Purpose:** Comprehensive RAG query with LLM generation

**When agents use it:**
- Need a comprehensive answer based on codebase
- Want LLM to synthesize information from multiple sources
- Complex questions requiring reasoning

**Example:**
```python
# Agent calls:
rag_query("How does the MAKER voting system work?", top_k=5)

# Returns:
"""
The MAKER voting system implements first-to-K voting where:
1. Coder generates N parallel candidates...
2. Voter evaluates each candidate...
3. First candidate to receive K votes wins...
[Generated by LLM based on retrieved context]
"""
```

## Agent Decision Making

Agents see tool descriptions and decide when to use RAG:

```json
{
  "name": "rag_search",
  "description": "Semantic search in codebase using RAG. Returns relevant code snippets with similarity scores.",
  "parameters": {
    "query": "Search query",
    "top_k": "Number of results (default: 5)"
  }
}
```

**Agent reasoning:**
- "I need to find how error handling works" → Use `rag_search`
- "I need to read a specific file" → Use `read_file`
- "I need a comprehensive answer" → Use `rag_query`
- "I need exact symbol references" → Use `find_references`

## Implementation Details

### Tool Discovery

```python
# In mcp_server.py
@app.get("/api/mcp/tools")
async def list_tools():
    tools = [/* standard MCP tools */]
    
    # Check if RAG is available
    if os.path.exists("data/rag_indexes/codebase.index"):
        tools.append({
            "name": "rag_search",
            ...
        })
        tools.append({
            "name": "rag_query",
            ...
        })
    
    return {"tools": tools}
```

**Key point:** RAG tools only appear if index exists. No configuration needed.

### Lazy Loading

```python
# RAG service loaded only when tool is called
_rag_service_cache = None

def _get_rag_service():
    global _rag_service_cache
    if _rag_service_cache is None:
        # Try to load RAG service
        # Returns None if not available
    return _rag_service_cache
```

**Benefits:**
- No startup overhead if RAG not used
- No errors if dependencies missing
- Graceful degradation

### Error Handling

```python
async def _call_rag_search(query: str, top_k: int = 5) -> str:
    rag = _get_rag_service()
    if not rag:
        return " RAG not available. Index codebase first: python3 scripts/index_codebase.py"
    
    try:
        results = rag.search(query, top_k=top_k)
        # ... format results
    except Exception as e:
        return f" RAG search error: {str(e)}"
```

**Agents receive clear error messages** if RAG unavailable, can fall back to other tools.

## Comparison: Automatic vs Agentic

### Old Approach (Automatic - REMOVED)

```python
# RAG automatically injected
if self.rag_enabled:
    rag_docs = rag.search(user_input)
    # Automatically added to context
```

**Problems:**
- ❌ Always runs even when not needed
- ❌ Adds latency to every request
- ❌ Hard dependency (system breaks if RAG fails)
- ❌ No agent control

### New Approach (Agentic - CURRENT)

```python
# RAG exposed as tool
# Agents call it when needed
tools = ["rag_search", "rag_query"]  # Only if index exists
```

**Benefits:**
- ✅ Only runs when agents need it
- ✅ No latency if not used
- ✅ Optional - system works without it
- ✅ Agents decide when to use it

## Usage Examples

### Scenario 1: Simple Code Request

```
User: "Write a hello world function"

[PLANNER]
- Doesn't need RAG
- Uses MCP tools if needed (read_file for examples)
- Proceeds normally

Result: Works without RAG
```

### Scenario 2: Complex Question

```
User: "How does the orchestrator handle errors?"

[PLANNER]
- Sees rag_search tool available
- Decides to use it: rag_search("orchestrator error handling")
- Gets relevant code snippets
- Uses them to answer question

Result: Better answer with RAG context
```

### Scenario 3: RAG Not Available

```
User: "How does the orchestrator handle errors?"

[PLANNER]
- rag_search tool not in list (no index)
- Uses MCP tools: analyze_codebase, read_file
- Still provides answer

Result: Works fine, just without semantic search
```

## Configuration

### No Configuration Needed!

RAG tools automatically appear if:
1. Index exists at `data/rag_indexes/codebase.index`
2. Dependencies installed (`faiss-cpu`, `sentence-transformers`)

### To Enable RAG

```bash
# 1. Install dependencies
bash scripts/setup-rag-faiss.sh

# 2. Index codebase
python3 scripts/index_codebase.py

# 3. Restart MCP server (or it will auto-detect)
docker compose restart mcp-server
```

**That's it!** RAG tools will appear in `/api/mcp/tools` automatically.

### To Disable RAG

```bash
# Just remove or rename the index
mv data/rag_indexes/codebase.index data/rag_indexes/codebase.index.bak

# Restart MCP server
docker compose restart mcp-server
```

RAG tools will disappear from the tools list.

## Benefits of Agentic Design

1. **Zero Dependencies**: System works without RAG
2. **Optimal Performance**: RAG only used when needed
3. **Agent Control**: Agents decide based on task
4. **Graceful Degradation**: Falls back to MCP tools
5. **Easy Toggle**: Just add/remove index file
6. **No Configuration**: Auto-detects availability

## Migration Notes

**Removed:**
- `RAG_ENABLED` environment variable (no longer needed)
- Automatic RAG injection in preprocessor/planner
- `_get_rag_service()` in orchestrator

**Added:**
- `rag_search` MCP tool
- `rag_query` MCP tool
- Automatic tool discovery based on index existence

**Backward Compatibility:**
- ✅ System works exactly as before without RAG
- ✅ No breaking changes
- ✅ RAG is purely additive

## Summary

✅ **RAG is now fully agentic** - agents call it as a tool when needed
✅ **System works without RAG** - no dependencies, no automatic calls
✅ **Zero configuration** - tools appear automatically if index exists
✅ **Optimal performance** - RAG only used when agents need it
✅ **Graceful degradation** - falls back to MCP tools if RAG unavailable

This is the correct MAKER architecture: agents have tools, they decide when to use them.

